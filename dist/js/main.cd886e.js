/*! For license information please see main.cd886e.js.LICENSE.txt */
(()=>{"use strict";var __webpack_modules__={"./css/index.css":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack:///./css/index.css?")},"./scripts/index.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__webpack_require__(/*! ../css/index.css */ \"./css/index.css\");\nvar BlockType;\n(function (BlockType) {\n    BlockType[BlockType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    BlockType[BlockType[\"MINE\"] = 1] = \"MINE\";\n})(BlockType || (BlockType = {}));\nlet row = 10, col = 10, mineNum = 0, exhibitNum = 0, time = 0;\nlet timer;\nconst blockFillStyle = '#2D3E4A', txtFillStyle = '#171617', flagFillStyle = '#95DCED';\nconst w = 20, h = 20;\nlet mapW, mapH;\nlet matrixMap;\nlet rmEvents;\nconst cvs = document.querySelector('canvas'), ctx = cvs.getContext('2d');\n/**\n * 主函数\n */\nfunction init() {\n    initState();\n    createMatrixMap();\n    initEvent();\n    render();\n}\nfunction gameStart() {\n    timer = setInterval(() => {\n        time++;\n    }, 1000);\n}\nfunction gameOver() {\n    time = 0;\n    clearInterval(timer);\n    rmEvents();\n}\nfunction initState() {\n    matrixMap = new Array(row).fill(null).map(() => new Array(col).fill(null));\n    mapW = cvs.width = w * col;\n    mapH = cvs.height = h * row;\n    mineNum = 0;\n    exhibitNum = 0;\n    time = 0;\n}\nfunction eventListener(el, type, listener) {\n    el.addEventListener(type, listener, false);\n    return () => el.removeEventListener(type, listener, false);\n}\nfunction initEvent() {\n    const rmClick = eventListener(cvs, 'click', ev => {\n        const { clientX: x, clientY: y } = ev, { offsetLeft: l, offsetTop: t } = cvs;\n        const r = ~~((y - t) / h), c = ~~((x - l) / w);\n        const block = matrixMap[r][c];\n        const { type } = block;\n        if (type == BlockType.MINE) {\n            bomb(block);\n        }\n        else {\n            if (exhibitNum === 0) {\n                // 游戏开始\n                gameStart();\n            }\n            const map = new Map();\n            const dfs = (block) => {\n                if (!block.exhibit) {\n                    exhibitNum++;\n                    block.exhibit = true;\n                    block.flag = false;\n                    const { mineNum, r, c } = block;\n                    if (mineNum === 0) {\n                        [[-1, 0], [1, 0], [-1, -1], [0, -1], [1, -1], [-1, 1], [0, 1], [1, 1]].forEach(([x, y]) => {\n                            const i = r + y, j = c + x, key = `${i}-${j}`;\n                            if (i >= 0 && i < row && j >= 0 && j < col && !map.has(key)) {\n                                map.set(key, true);\n                                dfs(matrixMap[i][j]);\n                            }\n                        });\n                    }\n                }\n            };\n            dfs(block);\n        }\n        render();\n        if (row * col - exhibitNum === mineNum) {\n            // 赢了\n            alert(`此时游戏耗时: ${time}s`);\n            time = 0;\n        }\n    });\n    const rmCtx = eventListener(cvs, 'contextmenu', ev => {\n        ev.preventDefault();\n        const { clientX: x, clientY: y } = ev, { offsetLeft: l, offsetTop: t } = cvs;\n        const r = ~~((y - t) / h), c = ~~((x - l) / w);\n        const block = matrixMap[r][c];\n        if (block.exhibit)\n            return false;\n        block.flag = !block.flag;\n        render();\n    });\n    rmEvents = () => {\n        rmCtx();\n        rmClick();\n    };\n}\nfunction bomb(block) {\n    block.fillStyle = '#A705ED';\n    matrixMap.forEach(blocks => blocks.forEach((block) => {\n        block = block;\n        const { type } = block;\n        if (type === BlockType.MINE) {\n            block.exhibit = true;\n            block.flag = false;\n        }\n    }));\n    render();\n    gameOver();\n}\n/**\n * 渲染函数\n */\nfunction render() {\n    ctx.clearRect(0, 0, mapW, mapH);\n    for (let r = 0; r < row; ++r) {\n        for (let c = 0; c < col; ++c) {\n            drawBlock(matrixMap[r][c]);\n        }\n    }\n}\n/**\n * 绘制单个块\n * @param block 单个块\n */\nfunction drawBlock(block) {\n    const { r, c, mineNum: num, exhibit, flag, fillStyle } = block;\n    const x = c * w, y = r * h;\n    ctx.beginPath();\n    ctx.strokeRect(x, y, w, h);\n    if (exhibit && fillStyle) {\n        ctx.fillStyle = fillStyle;\n        ctx.fillRect(x, y, w, h);\n    }\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillStyle = txtFillStyle;\n    if (num) {\n        ctx.fillText(String(num), x + w / 2, y + h / 2);\n    }\n    if (!exhibit) {\n        ctx.fillStyle = fillStyle || blockFillStyle;\n        ctx.fillRect(x, y, w, h);\n    }\n    if (flag) {\n        ctx.fillStyle = flagFillStyle;\n        ctx.fillRect(x, y, w, h);\n    }\n    ctx.closePath();\n}\n/**\n * 先布雷，再统计\n */\nfunction createMatrixMap() {\n    let num = mineNum = ~~(row * col / 10 + Math.random() * row * col / 10);\n    while (num > 0) {\n        const r = ~~(Math.random() * row), c = ~~(Math.random() * col);\n        if (!matrixMap[r][c]) {\n            matrixMap[r][c] = {\n                r, c,\n                exhibit: false,\n                mineNum: '*',\n                type: BlockType.MINE,\n                flag: false\n            };\n            num--;\n        }\n    }\n    for (let r = 0; r < row; ++r) {\n        for (let c = 0; c < col; ++c) {\n            if (!matrixMap[r][c]) {\n                const mineNum = [[-1, 0], [1, 0], [-1, -1], [0, -1], [1, -1], [-1, 1], [0, 1], [1, 1]].filter(([dx, dy]) => {\n                    const x = dx + c, y = dy + r;\n                    return x >= 0 && y >= 0 && x < col && y < row && matrixMap[y][x] && matrixMap[y][x].type === BlockType.MINE;\n                }).length;\n                matrixMap[r][c] = {\n                    r, c, exhibit: false,\n                    mineNum,\n                    type: BlockType.DEFAULT,\n                    flag: false\n                };\n            }\n        }\n    }\n}\neventListener(document.querySelector('.mine-sweeping'), 'click', ({ target }) => {\n    let level = Number(target.dataset.level);\n    if (!level)\n        return;\n    if (time) {\n        if (!confirm('游戏正在进行中,是否弃掉?')) {\n            return;\n        }\n    }\n    level = Math.max(Math.min(level, 3), 1);\n    col = row = level * 10;\n    gameOver();\n    init();\n});\ninit();\n\n\n//# sourceURL=webpack:///./scripts/index.ts?")}},__webpack_module_cache__={};function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e)return e.exports;var t=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](t,t.exports,__webpack_require__),t.exports}__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./scripts/index.ts")})();